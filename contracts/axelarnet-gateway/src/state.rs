use axelar_wasm_std::counter::Counter;
use axelar_wasm_std::IntoContractError;
use cosmwasm_schema::cw_serde;
use cosmwasm_std::{Addr, StdError, Storage};
use cw_storage_plus::{Item, Map};
use error_stack::report;
use router_api::{ChainName, CrossChainId, Message};

const CONFIG: Item<Config> = Item::new("config");
const ROUTABLE_MESSAGES: Map<&CrossChainId, Message> = Map::new("routable_messages");
pub(crate) const ROUTABLE_MESSAGES_INDEX: Counter<u32> = Counter::new("routable_message_index");
const EXECUTABLE_MESSAGES: Map<&CrossChainId, ExecutableMessage> = Map::new("executable_messages");

#[derive(thiserror::Error, Debug, PartialEq, IntoContractError)]
pub enum Error {
    #[error(transparent)]
    Std(#[from] StdError),
    #[error("gateway got into an invalid state, its config is missing")]
    MissingConfig,
    #[error("message with ID {0} mismatches with the stored one")]
    MessageMismatch(CrossChainId),
    #[error("message with ID {0} not found")]
    MessageNotFound(CrossChainId),
    #[error("message with ID {0} not approved")]
    MessageNotApproved(CrossChainId),
    #[error("message with ID {0} already executed")]
    MessageAlreadyExecuted(CrossChainId),
    #[error("sent message with ID {0} already exists")]
    MessageAlreadyExists(CrossChainId),
    #[error("payload hash doesn't match message")]
    PayloadHashMismatch,
}

#[cw_serde]
pub(crate) struct Config {
    pub chain_name: ChainName,
    pub router: Addr,
}

#[cw_serde]
pub enum ExecutableMessage {
    // sent by the router, but not executed yet
    Approved(Message),
    Executed(Message),
}

impl ExecutableMessage {
    pub fn msg(&self) -> &Message {
        match self {
            ExecutableMessage::Approved(msg) | ExecutableMessage::Executed(msg) => msg,
        }
    }

    pub fn msg_owned(self) -> Message {
        match self {
            ExecutableMessage::Approved(msg) | ExecutableMessage::Executed(msg) => msg,
        }
    }
}

pub(crate) fn save_config(storage: &mut dyn Storage, value: &Config) -> Result<(), Error> {
    Ok(CONFIG.save(storage, value)?)
}

pub(crate) fn load_config(storage: &dyn Storage) -> Result<Config, Error> {
    CONFIG.may_load(storage)?.ok_or(Error::MissingConfig)
}

pub(crate) fn save_unique_routable_msg(
    storage: &mut dyn Storage,
    cc_id: &CrossChainId,
    msg: &Message,
) -> Result<(), Error> {
    // these cc IDs are generated by the gateway and should be unique.
    // If there is a collision, there must be a bug in the logic of the caller.
    if ROUTABLE_MESSAGES.has(storage, cc_id) {
        return Err(Error::MessageAlreadyExists(cc_id.clone()));
    }

    Ok(ROUTABLE_MESSAGES.save(storage, cc_id, msg)?)
}

pub(crate) fn may_load_routable_msg(
    storage: &dyn Storage,
    id: &CrossChainId,
) -> Result<Option<Message>, Error> {
    Ok(ROUTABLE_MESSAGES.may_load(storage, id)?)
}

pub fn load_routable_msg(storage: &dyn Storage, id: &CrossChainId) -> Result<Message, Error> {
    may_load_routable_msg(storage, id)?.ok_or_else(|| Error::MessageNotFound(id.clone()))
}

pub(crate) fn save_executable_msg(
    storage: &mut dyn Storage,
    cc_id: &CrossChainId,
    msg: Message,
) -> Result<(), Error> {
    let existing = may_load_executable_msg(storage, cc_id)?;

    match existing {
        Some(with_status) if *with_status.msg() != msg => {
            Err(Error::MessageMismatch(msg.cc_id.clone()))
        }
        Some(_) => Ok(()), // new message is identical, no need to store it
        None => Ok(EXECUTABLE_MESSAGES.save(storage, cc_id, &ExecutableMessage::Approved(msg))?),
    }
}

pub(crate) fn may_load_executable_msg(
    storage: &dyn Storage,
    cc_id: &CrossChainId,
) -> Result<Option<ExecutableMessage>, Error> {
    Ok(EXECUTABLE_MESSAGES.may_load(storage, cc_id)?)
}

pub fn load_executable_msg(
    storage: &dyn Storage,
    cc_id: &CrossChainId,
) -> Result<ExecutableMessage, Error> {
    may_load_executable_msg(storage, cc_id)?.ok_or_else(|| Error::MessageNotApproved(cc_id.clone()))
}

/// Update the status of a message to executed if it is in approved status, error otherwise.
pub(crate) fn update_as_executed(
    storage: &mut dyn Storage,
    cc_id: &CrossChainId,
    action: impl FnOnce(Message) -> Result<Message, Error>,
) -> Result<Message, Error> {
    let msg = match may_load_executable_msg(storage, cc_id)? {
        None => Err(Error::MessageNotApproved(cc_id.clone())),
        Some(ExecutableMessage::Executed(_)) => Err(Error::MessageAlreadyExecuted(cc_id.clone())),
        Some(ExecutableMessage::Approved(msg)) => Ok(action(msg)?),
    }?;

    EXECUTABLE_MESSAGES.save(storage, cc_id, &ExecutableMessage::Executed(msg.clone()))?;

    Ok(msg)
}

//
// #[cfg(test)]
// mod tests {
//     use cosmwasm_std::testing::mock_dependencies;
//     use cosmwasm_std::Addr;
//     use router_api::{CrossChainId, Message};
//
//     use super::*;
//
//     fn create_test_message() -> Message {
//         Message {
//             cc_id: CrossChainId::new("source-chain", "message-id").unwrap(),
//             source_address: "source-address".parse().unwrap(),
//             destination_chain: "destination-chain".parse().unwrap(),
//             destination_address: "destination-address".parse().unwrap(),
//             payload_hash: [1; 32],
//         }
//     }
//
//     #[test]
//     fn config_storage() {
//         let mut deps = mock_dependencies();
//
//         let config = Config {
//             chain_name: "test-chain".parse().unwrap(),
//             router: Addr::unchecked("router-address"),
//         };
//
//         // Test saving config
//         super::save_config(deps.as_mut().storage, &config).unwrap();
//
//         // Test loading config
//         let loaded_config = super::load_config(deps.as_ref().storage).unwrap();
//         assert_eq!(config, loaded_config);
//
//         // Test loading non-existent config
//         CONFIG.remove(deps.as_mut().storage);
//         let result = super::load_config(deps.as_ref().storage);
//         assert_eq!(result, Err(Error::MissingConfig));
//     }
//
//     #[test]
//     fn sent_message_storage() {
//         let mut deps = mock_dependencies();
//         let message = create_test_message();
//
//         // Test saving sent message
//         super::save_unique_contract_call_msg(
//             deps.as_mut().storage,
//             message.cc_id.clone(),
//             &message,
//         )
//         .unwrap();
//
//         // Test loading sent message
//         let loaded_message =
//             super::may_load_contract_call_msg(deps.as_ref().storage, &message.cc_id).unwrap();
//         assert_eq!(Some(message.clone()), loaded_message);
//
//         // Test loading non-existent message
//         let non_existent_id = CrossChainId::new("non-existent", "id").unwrap();
//         assert_eq!(
//             None,
//             super::may_load_contract_call_msg(deps.as_ref().storage, &non_existent_id).unwrap()
//         );
//
//         // Test saving duplicate message
//         let result = super::save_unique_contract_call_msg(
//             deps.as_mut().storage,
//             message.cc_id.clone(),
//             &message,
//         );
//         assert_eq!(result, Err(Error::MessageAlreadyExists(message.cc_id)));
//     }
//
//     #[test]
//     fn received_message_storage() {
//         let mut deps = mock_dependencies();
//         let message = create_test_message();
//
//         // Test saving received message
//         super::save_executable_msg(
//             deps.as_mut().storage,
//             message.cc_id.clone(),
//             message.clone(),
//         )
//         .unwrap();
//
//         // Test loading received message
//         let loaded_message =
//             super::may_load_executable_msg(deps.as_ref().storage, &message.cc_id).unwrap();
//         assert_eq!(
//             Some(ExecutableMessage {
//                 msg: message.clone(),
//                 status: MessageStatus::Approved
//             }),
//             loaded_message
//         );
//
//         // Test loading non-existent message
//         let non_existent_id = CrossChainId::new("non-existent", "id").unwrap();
//         assert_eq!(
//             None,
//             super::may_load_executable_msg(deps.as_ref().storage, &non_existent_id).unwrap()
//         );
//
//         // Test saving duplicate message (should not error, but also not change the stored message)
//         super::save_executable_msg(
//             deps.as_mut().storage,
//             message.cc_id.clone(),
//             message.clone(),
//         )
//         .unwrap();
//         let loaded_message =
//             super::may_load_executable_msg(deps.as_ref().storage, &message.cc_id).unwrap();
//         assert_eq!(
//             Some(ExecutableMessage {
//                 msg: message.clone(),
//                 status: MessageStatus::Approved
//             }),
//             loaded_message
//         );
//
//         // Test saving mismatched message
//         let mismatched_message = Message {
//             cc_id: message.cc_id.clone(),
//             source_address: "different-address".parse().unwrap(),
//             ..message.clone()
//         };
//         let result = super::save_executable_msg(
//             deps.as_mut().storage,
//             message.cc_id.clone(),
//             mismatched_message,
//         );
//         assert_eq!(result, Err(Error::MessageMismatch(message.cc_id)));
//     }
//
//     #[test]
//     fn set_msg_as_executed() {
//         let mut deps = mock_dependencies();
//         let message = create_test_message();
//
//         // Save a received message
//         super::save_executable_msg(
//             deps.as_mut().storage,
//             message.cc_id.clone(),
//             message.clone(),
//         )
//         .unwrap();
//
//         // Test setting message as executed
//         let executed_message =
//             super::mark_msg_as_executed(deps.as_mut().storage, message.cc_id.clone()).unwrap();
//         assert_eq!(message, executed_message);
//
//         // Verify the message status is now Executed
//         let loaded_message =
//             super::may_load_executable_msg(deps.as_ref().storage, &message.cc_id).unwrap();
//         assert_eq!(
//             Some(ExecutableMessage {
//                 msg: message.clone(),
//                 status: MessageStatus::Executed
//             }),
//             loaded_message
//         );
//
//         // Test setting an already executed message
//         let result = super::mark_msg_as_executed(deps.as_mut().storage, message.cc_id.clone());
//         assert_eq!(result, Err(Error::MessageAlreadyExecuted(message.cc_id)));
//
//         // Test setting a non-existent message
//         let non_existent_id = CrossChainId::new("non-existent", "id").unwrap();
//         let result = super::mark_msg_as_executed(deps.as_mut().storage, non_existent_id.clone());
//         assert_eq!(result, Err(Error::MessageNotApproved(non_existent_id)));
//     }
//
//     #[test]
//     fn increment_msg_counter() {
//         let mut deps = mock_dependencies();
//
//         for i in 1..=3 {
//             let count = super::increment_msg_counter(deps.as_mut().storage).unwrap();
//             assert_eq!(i, count);
//         }
//     }
// }
